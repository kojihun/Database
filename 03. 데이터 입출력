<논리 데이터 모델 검증>
*논리 데이터 모델링 개념
 -데이터베이스 설계 프로세스의 기초 설계 단계로 비즈니스 정보의 구조와 규칙을 명확하게 표현할 수 있는 기법
 -개념 모델로부터 업무 영역의 업무 데이터 및 규칙을 구체적으로 표현한 모델

*논리 데이터 모델링의 특성
 -정규화: 모든 데이터를 정규화하여 모델링
 -포용성: 모든 엔티티 타입, 속성, 관계 프로세스등을 포함
 -완전성: 모든 규칙과 관계를 완전하고 정확하게 표현
 -독립성: 성능, 제약사항에 독립적인 모델, 특정 DBMS로부터 독립적인 성질

*논리 데이터 모델링 속성
 -개체: 관리할 대상이 되는 실체
 -속성: 관리할 정보의 구체적 항목
 -관계: 개체 간의 대응 관계

*E-R모델
 -논리 데이터 모델링에서는 모든 이해당사자와 의사소통의 보조 자료로 E-R모델을 활용
 -요구사항으로부터 얻어낸 정보들을 개체, 속성, 관계로 기술한 모델

*정규화
 -관계형 데이터베이스의 설계에서 중복을 최소화하여 데이터를 구조화하는 프로세스

*이상 현상
 -데이터의 중복성으로 인해 릴레이션을 조작할 때 발생하는 비합리적 현상
 -삽입, 삭제, 갱신 이상이 있음
 
 -삽입이상: 정보 저장 시 해당 정보의 불필요한 세부정보를 입력해야 하는 경우
 -삭제이상: 정보 삭제 시 원치 않는 다른 정보가 같이 삭제되는 경우
 -갱신 이상: 중복 데이터 중에서 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우

*정규화 단계
 -1정규형: 원자값으로 구성
 -2정규형: 부분 함수 종속 제거(완전 함수적 종속 관계)
 -3정규형: 이행함수 종속 제거
 -보이스-코드 정규형: 결정자 함수이면서 후보키가 아닌 것 제거
 -4정규형: 다치(다중 값) 종속성 제거
 -5정규형: 조인 종속성 제거

<물리 데이터 저장소 설계>
*물리 데이터 모델링 개념
 -물리 데이터 모델링은 논리 모델을 적용하고자 하는 기술에 맞도록 상세화해가는 과정

*물리 데이터 모델링 변환 절차
 -개체를 테이블로 변환
 -속성을 컬럼으로 변환
 -UID를 기본키로 변환
 -관계를 외래키로 변환
 -컬럼 유형과 길이 정의
 -반 정규화 수행

<테이블 제약조건 설계>
*참조무결성 제약조건
 -릴레이션과 릴레이션 사이에 대해 참조의 일관성을 보장하기 위한 조건
 -두 개의 릴레이션이 기본키, 외래키를 통해 참조관계를 형성할 경우, 참조하는 외래키의 값은 항상 참조되는 릴레이션에 기본키로 존재하야한다.

*제한
 -참조 무결성 원칙을 위배하는 연산을 거절하는 옵션

*연쇄
 -참조되는 릴레이션에서 튜플을 삭제하고, 참조되는 릴레이션에서 이 튜플을 참조하는 튜플들도 함께 삭제하는 옵션

*널 값
 -참조되는 릴레이션에서 튜플을 삭제하고, 참조하는 릴레이션에서 해당 튜플을 참조하는 튜플들의 외래키에 NULL값이 들어갈 애트리뷰트에 NOT NULL이라고 명시되어 있다면 삭제 연산을 거절

<인덱스 설계>
*인덱스 개념
 -검색 연산의 최적화를 위해 데이터베이스 내 열에 대한 정보를 구성한 데이터 구조
 -인덱스를 통해 전체 데이터의 검색 없이 필요한 정보에 대해 신속한 조화가 가능

*인덱스 적용 기준
 -분포도: (1/(컬럼 값의 종류) X 100
 -분포도: (컬럼 값의 평균 Row 수) / (테이블의 총 Row수) X 100

*인덱스 컬럼 선정
 -분포도가 좋은 컬럼은 단독적으로 생성
 -자주 조합되어 사용한 컬럼은 결합 인덱스로 생성
 -결합 인덱스는 구성되는 컬럼 순서 선정
 -가능한 한 수정이 빈번하지 않은 컬럼을 선정

*설계 시 고려 사항
 -지나치게 많은 인덱스는 오버헤드로 작용한다.
 -인덱스는 추가적인 저장 공간이 필요함을 고려해야한다.
 -넓은 범위를 인덱스 처리 시 오히려 전체 처리보다 많은 오버헤드를 발생 시킬 수 있음
 -인덱스와 테이블의 저장 공간을 적절히 분리될 수 있도록 설계해야 한다.

<뷰 설계>
 -REPLACE: 뷰가 이미 존재하는 경우 재생성
 -FORCE: 본 테이블의 존재 여부에 관계없이 뷰 생성
 -NOFORCE: 기본 테이블이 존재할 때 뷰 생성
 -WITH CHECK OPTION: 서브 쿼리 내의 조건을 만족하는 행만 변경
 -WITH READ ONLY: 데이터 조작어 작업 불가

<클러스터 설계>
*적용 기준
 -인덱스의 단점을 해결한 기법으로, 분포도가 넓을수록 오히려 유리하다.
 -액세스 기법이 아니라 액세스 효율 향상을 위한 물리적 저장 방법
 -대량의 범위를 자주 액세스하는 경우 적용
 -인덱스를 사용한 처리 부담이 되는 넓은 분포도에 활용
 -여러 개의 테이블이 빈번하게 조인을 일으킬 때 활용

<파티션 설계>
*레인지 파티셔닝
 -연속적인 숫자나 날짜를 기준으로 하는 파티셔닝 기법
 -손쉬운 관리 기법을 제공하여 관리 시간의 단축 가능

*해시 파티셔닝
 -파티션 키의 해시 함수 값에 의한 파티셔닝 기법
 -균등한 데이터 분할이 가능하고 질의 성능이 향상

*리스트 파티셔닝
 -특정 파티션에 저장 될 데이터에 대한 명시적 제어가 가능한 파티셔닝기법
 -분포도가 비슷하고 데이터가 많은 SQL에서 컬럼의 조건이 많이 들어오는 경우 유용

*컴포지트 파티셔닝
 -범위분할에 이후 해시 함수를 적용하여 재분할 하는 파티셔닝 기법
 -큰 파티션에 대한 I/O요청을 여러 파티션으로 분산할 수 있다.

<디스크 구성 설계>
 -정확한 용량을 산정하여 디스크 사용의 효율을 높인다.
 -업무량이 집중되어 있는 디스크를 분리하여 설계
 -입출력 경합을 최소화하여 데이터의 접근 성능을 향상시킨다.
 -디스크 구성에 따라 테이블 스페이스 개수와 사이즈등을 결정
